[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bienvenidos",
    "section": "",
    "text": "Datos b√°sicos del curso\n\n\n\nMateriales preparados para el curso impartido en la plataforma YoSigo UGR de la Universidad de Granada por Sergio Castro-Cortacero y Nicol√°s Robinson-Garc√≠a el d√≠a 8 de noviembre de 2024."
  },
  {
    "objectID": "index.html#objetivos-de-la-sesi√≥n",
    "href": "index.html#objetivos-de-la-sesi√≥n",
    "title": "Bienvenidos",
    "section": "üéØObjetivos de la sesi√≥n",
    "text": "üéØObjetivos de la sesi√≥n\nEsta web contiene los contenidos del curso de YoSigo UGR Introducci√≥n al an√°lisis de textos con Quanteda. En esta sesi√≥n queremos iniciarte en el fant√°stico mundo del an√°lisis de textos. Para ello vamos a utilizar el lenguaje de programaci√≥n R y el paquete de an√°lisis de textos Quanteda. Para ello vamos a explorar algunas cuestiones b√°sicas para el an√°lisis de textos como es la creaci√≥n de un corpus, el proceso de tokenizaci√≥n y algunos an√°lisis b√°sicos. Al terminar esta sesi√≥n deber√≠as poder hacer lo siguiente:\n\nEntender los fundamentos b√°sicos de miner√≠a de datos.\nSer capaz de importar y tokenizar un texto empleando el paquete de R quanteda.\nRealizar un an√°lisis pr√°ctico utilizando un corpus de texto real."
  },
  {
    "objectID": "index.html#antes-de-comenzar",
    "href": "index.html#antes-de-comenzar",
    "title": "Bienvenidos",
    "section": "ü´∂Antes de comenzar",
    "text": "ü´∂Antes de comenzar\nPara poder repetir las cosas que vamos a hacer en este curso y poder realizar tus propios an√°lisis, deber√°s de tener instalado en tu ordenador los siguientes programas (inst√°lalos en el orden que te indico):\n\nR. Este es el lenguaje programaci√≥n que emplearemos. Se trata de un lenguaje abierto y gratuito desarrollado espec√≠ficamente para el an√°lisis estad√≠stico. Aunque como con cualquier otro lenguaje de programaci√≥n, es muy flexible y puede emplearse para diferentes funciones. Cuenta con una amplia comunidad de usuarios que crean y mantienen sus funcionalidades creando lo que se conoce como paquetes o librer√≠as.\nRStudio. Se trata de una interfaz de R que facilita algunas operaciones. Aunque en principio, R puede emplearse sin interfaz, RStudio incluye los principales paquetes adicionales as√≠ como algunas funcionalidades que pueden ser muy √∫tiles para mantenernos cuerdos al adentrarnos en el mundo de la programaci√≥n.\n\n\nüí° Aqu√≠ te daremos el c√≥digo muy mascadito, pero si no tienes experiencia programando con R y deseas conocer las bases de su gram√°tica, te recomiendo los siguientes recursos:\n\nEl curso de yosigo Introducci√≥n pr√°ctica a la ciencia de datos en R ‚Äì REDUX by Wenceslao Arroyo-Machado\nEl libro online R for Data Science by Hadley Wickham, uno de los m√°ximos exponentes en R"
  },
  {
    "objectID": "ysp_tutorial.html",
    "href": "ysp_tutorial.html",
    "title": "An√°lisis de textos",
    "section": "",
    "text": "El an√°lisis de textos es el proceso de convertir grandes vol√∫menes de texto en datos estructurados que nos permitan identificar patrones, tendencias, y relaciones dentro de ese texto. Es una t√©cnica fundamental en campos como las ciencias sociales, humanidades digitales, marketing, y pol√≠tica, ya que permite explorar y entender la informaci√≥n contenida en textos de manera cuantitativa.\nA medida que el volumen de informaci√≥n textual digitalizada ha crecido, la necesidad de analizar textos de forma sistem√°tica tambi√©n ha aumentado. Herramientas como quanteda permiten a los investigadores y analistas transformar textos en datos estructurados y cuantificables."
  },
  {
    "objectID": "ysp_tutorial.html#introducci√≥n-al-an√°lisis-cuantitativo-de-textos",
    "href": "ysp_tutorial.html#introducci√≥n-al-an√°lisis-cuantitativo-de-textos",
    "title": "An√°lisis de textos",
    "section": "",
    "text": "El an√°lisis de textos es el proceso de convertir grandes vol√∫menes de texto en datos estructurados que nos permitan identificar patrones, tendencias, y relaciones dentro de ese texto. Es una t√©cnica fundamental en campos como las ciencias sociales, humanidades digitales, marketing, y pol√≠tica, ya que permite explorar y entender la informaci√≥n contenida en textos de manera cuantitativa.\nA medida que el volumen de informaci√≥n textual digitalizada ha crecido, la necesidad de analizar textos de forma sistem√°tica tambi√©n ha aumentado. Herramientas como quanteda permiten a los investigadores y analistas transformar textos en datos estructurados y cuantificables."
  },
  {
    "objectID": "ysp_tutorial.html#para-qu√©-se-utiliza-el-an√°lisis-de-textos",
    "href": "ysp_tutorial.html#para-qu√©-se-utiliza-el-an√°lisis-de-textos",
    "title": "An√°lisis de textos",
    "section": "ü§î ¬øPara qu√© se utiliza el an√°lisis de textos?",
    "text": "ü§î ¬øPara qu√© se utiliza el an√°lisis de textos?\n\n\n\n\n\n\n\nAn√°lisis de sentimiento\nEvaluar el tono emocional de textos, como rese√±as o comentarios en redes sociales, para conocer las opiniones y actitudes de los usuarios.\n\n\nAn√°lisis de tendencias\nIdentificar la frecuencia de palabras o frases clave y su cambio a lo largo del tiempo.\n\n\nAn√°lisis del discurso\nExplorar c√≥mo ciertos temas o ideas son representados en la sociedad y su evoluci√≥n temporal\n\n\nClasificaci√≥n autom√°tica de textos\nOrganizar categ√≥ricamente textos y fragmentos de textos a trav√©s de t√©cnicas como topic modeling o similares"
  },
  {
    "objectID": "ysp_tutorial.html#quanteda-como-herramienta-para-el-an√°lisis-de-datos",
    "href": "ysp_tutorial.html#quanteda-como-herramienta-para-el-an√°lisis-de-datos",
    "title": "An√°lisis de textos",
    "section": "‚úçÔ∏è Quanteda como herramienta para el an√°lisis de datos",
    "text": "‚úçÔ∏è Quanteda como herramienta para el an√°lisis de datos\nQuanteda es un paquete de R dise√±ado espec√≠ficamente para el an√°lisis cuantitativo de textos. Su valor principal radica en que ofrece una forma r√°pida, flexible y eficiente de transformar textos en datos estructurados, permitiendo a los investigadores trabajar con grandes vol√∫menes de texto de manera sistem√°tica. Quanteda es ideal para el procesamiento inicial y an√°lisis exploratorio de textos."
  },
  {
    "objectID": "ysp_tutorial.html#por-qu√©-quanteda",
    "href": "ysp_tutorial.html#por-qu√©-quanteda",
    "title": "An√°lisis de textos",
    "section": "‚ÅâÔ∏è ¬øPor qu√© quanteda?",
    "text": "‚ÅâÔ∏è ¬øPor qu√© quanteda?\n\n\n\n\n\n\n\nFacilidad en la preprocesamiento\nPermite realizar tareas como tokenizaci√≥n y limpieza de datos de forma r√°pida y eficiente.\n\n\nAn√°lisis de frecuencias\nFacilita el c√°lculo de frecuencias de t√©rminos en un corpus, ideal para identificar palabras clave y patrones.\n\n\nExploraci√≥n de contexto (KWIC)\nLa funci√≥n KWIC permite analizar palabras en su contexto, proporcionando insights sobre el uso de ciertos t√©rminos.\n\n\nAn√°lisis de sentimiento y temas\nPermite aplicar diccionarios de sentimiento y realizar an√°lisis b√°sico de temas mediante co-ocurrencia de palabras.\n\n\nFlexibilidad y escalabilidad\nOptimizado para manejar grandes vol√∫menes de texto y se integra f√°cilmente con otros paquetes para an√°lisis avanzados."
  },
  {
    "objectID": "dataprocessing.html",
    "href": "dataprocessing.html",
    "title": "Carga y procesamiento de textos",
    "section": "",
    "text": "Antes de comenzar el an√°lisis es obligatorio instalar dos paquetes b√°sicos: quanteda y readtext a trav√©s del comando: install.packages(\") . En primer lugar, para poder instalar quanteda , as√≠ como cualquier otro paquete en R, deberemos de de introducir en la consola el comando:\n\ninstall.packages(\"quanteda\")\n\nLa misma f√≥rmula aplicaremos para el paquete readtext\n\ninstall.packages(\"readtext\")\n\n\n\n\nquanteda es la herramienta que nos va a proporcionar los recursos para hacer un an√°lisis cuantitativo de un texto, incluyendo la tokenizaci√≥n[1], la creaci√≥n de matrices de t√©rminos y el an√°lisis de frecuencia.\nreadtext se utiliza para cargar y leer datos textuales desde diferentes formatos (como archivos de texto, documentos de Word, etc.). Para evitar dolores de cabeza, nosotros recomendamos que el material que se vaya a trabajar est√© en un formato plano .txt. Los formatos anteriores pueden dar problemas por la forma en que se estructuran los datos y los elementos adicionales que suelen contener, lo que requiere aplicar procesos adicionales de limpieza que puede alargar nuestro an√°lisis.\n\n¬øSab√≠as qu√©‚Ä¶? Ô∏èü§ì‚òù\n\n[1] En quanteda hablamos de tokenizaci√≥n para referirnos a la unidad m√≠nima de trabajo.\nImaginate que tienes la siguiente oraci√≥n:\n‚ÄúHola, ¬øc√≥mo est√°s?‚Äù\nLa tokenizaci√≥n de esta frase podr√≠a dar como resultado los siguientes tokens: ‚ÄúHola‚Äù, ‚Äú¬ø‚Äù, ‚Äúc√≥mo‚Äù, ‚Äúest√°s‚Äù, ‚Äú?‚Äù\nEsto es especialmente √∫til cuando estamos trabajando con estudios relacionados con frecuencias de palabras."
  },
  {
    "objectID": "dataprocessing.html#preparando-los-paquetes",
    "href": "dataprocessing.html#preparando-los-paquetes",
    "title": "Carga y procesamiento de textos",
    "section": "",
    "text": "Antes de comenzar el an√°lisis es obligatorio instalar dos paquetes b√°sicos: quanteda y readtext a trav√©s del comando: install.packages(\") . En primer lugar, para poder instalar quanteda , as√≠ como cualquier otro paquete en R, deberemos de de introducir en la consola el comando:\n\ninstall.packages(\"quanteda\")\n\nLa misma f√≥rmula aplicaremos para el paquete readtext\n\ninstall.packages(\"readtext\")\n\n\n\n\nquanteda es la herramienta que nos va a proporcionar los recursos para hacer un an√°lisis cuantitativo de un texto, incluyendo la tokenizaci√≥n[1], la creaci√≥n de matrices de t√©rminos y el an√°lisis de frecuencia.\nreadtext se utiliza para cargar y leer datos textuales desde diferentes formatos (como archivos de texto, documentos de Word, etc.). Para evitar dolores de cabeza, nosotros recomendamos que el material que se vaya a trabajar est√© en un formato plano .txt. Los formatos anteriores pueden dar problemas por la forma en que se estructuran los datos y los elementos adicionales que suelen contener, lo que requiere aplicar procesos adicionales de limpieza que puede alargar nuestro an√°lisis.\n\n¬øSab√≠as qu√©‚Ä¶? Ô∏èü§ì‚òù\n\n[1] En quanteda hablamos de tokenizaci√≥n para referirnos a la unidad m√≠nima de trabajo.\nImaginate que tienes la siguiente oraci√≥n:\n‚ÄúHola, ¬øc√≥mo est√°s?‚Äù\nLa tokenizaci√≥n de esta frase podr√≠a dar como resultado los siguientes tokens: ‚ÄúHola‚Äù, ‚Äú¬ø‚Äù, ‚Äúc√≥mo‚Äù, ‚Äúest√°s‚Äù, ‚Äú?‚Äù\nEsto es especialmente √∫til cuando estamos trabajando con estudios relacionados con frecuencias de palabras."
  },
  {
    "objectID": "dataprocessing.html#volcando-los-archivos-de-texto-a-rstudio",
    "href": "dataprocessing.html#volcando-los-archivos-de-texto-a-rstudio",
    "title": "Carga y procesamiento de textos",
    "section": "üìÑ‚û°Ô∏èüñ•Ô∏èVolcando los archivos de texto a RStudio",
    "text": "üìÑ‚û°Ô∏èüñ•Ô∏èVolcando los archivos de texto a RStudio\nVamos a vincular el archivo de¬†texto en la aplicaci√≥n de RStudios. Para ello vamos a aplicar los dos paquetes que hemos instalado anteriormente¬†con el comando library(\"name\")\n\nlibrary(\"quanteda\")\nlibrary(\"readtext\")\n\nEs importante resaltar que, si no llamamos antes el paquete, los comandos que introduzcamos despu√©s no funcionar√°n o nos dar√°n error. Aseg√∫rate de cargar siempre la librer√≠a antes de empezar a trabajar.\nUna vez cargados, el programa estar√° listo para leer nuestro archivo de texto. La formula que vamos a escribir para decirle a quanteda que archivo analizar ser√° el siguiente:\n\ndata_char_NALVANY &lt;- as.character(readtext::readtext(\"G:/Mi unidad/Yo sigo/NALVANY.txt\"))\nnames(data_char_NALVANY) &lt;- \"NALVANY\"\n\n‚ùóATENICI√ìN: Si por alguna raz√≥n hiciesemos alg√∫n cambio en el contenido del archivo, deberemos de aplicar el paso anterior de nuevo. Cuando cargamos un archivo en R, se guarda una copia y cualquier cambio en el original no se refleja autom√°ticamente.\n\nü§î¬øQu√© significa esta funci√≥n?\nVamos a desgranar este prompt para que pueda entenderse m√°s facil:\n\ndata_char_\"TEXTO\": La variable data_char_NALVANY es un objeto[2] en R que almacena el texto como una cadena de caracteres (character vector).\nas.character(): Convierte el objeto cargado en un formato de texto sencillo, que es m√°s f√°cil de manejar para el an√°lisis.\nreadtext::readtext: Como v√©is, se ha utilizado una expresi√≥n doble del paquete readtext. Esto proviene de la notaci√≥n paquete::funci√≥n y se hace cuando queremos asegurarnos de utilizar una funci√≥n espec√≠fica. Aqu√≠, lo que le estamos diciendo a RStudios es que, del paquete readtext, aplique espec√≠ficamente la funci√≥n lectura que casualmente tambi√©n se llama readtext\n\nUn problema muy com√∫n que puede surgir a la hora de introducir la URL de la ubicaci√≥n del archivo es expresarlo con barras laterales izquierdas ‚Äù \\ ‚Äú, tal y como viene en la barra de direcci√≥n del explorador de archivos de Windows, en vez de la derecha‚Äù / ‚Äú. Si tienes problemas leer tu .txt ¬°prueba con hacer este cambio!\n\nnames(data_char_NALVANY) &lt;- \"Nalvany\": Asigna un nombre al objeto que contiene el texto, facilitando su identificaci√≥n en futuros an√°lisis.\n\n¬øSab√≠as qu√©‚Ä¶? Ô∏èü§ì‚òù\n\n[2] En R hablamos de objetos para referirnos a los contenedores donde almacenamos datos e informaci√≥n. En el caso anterior, el objeto data_char_NALVANY almacena el texto plano que vamos a utilizar.\nExisten distintos objetos con diferentes datos almacenados: matrices, n√∫meros, listas jerarquizadas, as√≠ como un sin fin de combinaciones. A lo largo de este caso pr√°ctico trabajaremos con ellos para gestionar m√°s facilmente el an√°lisis cuantitativo.\n\n\n\nüîç Comprobaciones\nEn el an√°lisis cuantitativo toda precauci√≥n es poca , as√≠ que vamos a realizar una serie de comprobaciones para verificar que el texto ha sido leido por el programa. Para ello, vamos a pedirle a RStudio que nos devuelva los primeros 75 caracteres de nuestro archivo NALVANY.txt mediante el paquete: stringi.\n\nlibrary.(\"stringi\") #Primero llamamos al paquete\nstri_sub(data_char_NALVANY, 1, 75) #Aplicamos la funci√≥n para que nos devuelva los caracteres situados entre la posici√≥n 1 y 75.\n\nSi hemos hecho los pasos bien, tendr√©is que haber recibir este texto de vuelta:\n[1] \"2022\\nJanuary 17th\\nExactly one year ago today I came home, to Russia.\\nI didn\""
  },
  {
    "objectID": "dataprocessing.html#discriminaci√≥n-del-texto",
    "href": "dataprocessing.html#discriminaci√≥n-del-texto",
    "title": "Carga y procesamiento de textos",
    "section": "üóÉÔ∏èDiscriminaci√≥n del texto",
    "text": "üóÉÔ∏èDiscriminaci√≥n del texto"
  },
  {
    "objectID": "dataprocessing.html#acotando-nuestro-espacio-de-trabajo",
    "href": "dataprocessing.html#acotando-nuestro-espacio-de-trabajo",
    "title": "Carga y procesamiento de textos",
    "section": "üóÉÔ∏èAcotando nuestro espacio de trabajo",
    "text": "üóÉÔ∏èAcotando nuestro espacio de trabajo\nNuestro siguiente objetivo es seleccionar qu√© partes del texto vamos aplicar el an√°lisis cuantitativo. Puede que nuestro foco de inter√©s sea algun apartado concreto de nuestro material, por lo que vamos a crear un objeto que albergue un rango determinado dentro de nuestro ‚Äú‚Äú.txt . Con esto nos quitaremos toda la informaci√≥n innecesaria que puede ensuciar nuestros resultados.\nEl proceso que vamos a realizar a continuaci√≥n es muy √∫til cuando los archivos que manejamos tienen ligados metadatos. Normalmente, esta metadata suele ser m√°s un dolor de cabeza que otra cosa y es recomendable realizar una limpieza previa para que esos datos no se mezclen con el contenido de nuestro an√°lisis.\nEn este apartado seguiremos trabajando con el paquete stringi [3]\n\nPASO 1: Asignaci√≥n de los rangos del texto\nPara crear el objeto que albergue el rango de texto a analizar deberemos empezar indicando donde empieza y termina nuestra selecci√≥n. Para ello, crearemos dos valores de posici√≥n: start_v y end_v, donde start_ ser√°: ‚Äú2023, January 12th‚Äù y end_v ‚ÄúFIN‚Äù.\nLocalizado el rango que queremos, la forma de expresarlo en el programa ser√≠a el siguiente:\n\n(start_v &lt;- stri_locate_first_fixed(data_char_NALVANY, \"2023\\nJanuary 12th\")[1])\n\n\n(end_v &lt;- stri_locate_last_fixed(data_char_NALVANY, \"FIN\")[1])\n\nSi lo hemos aplicado bien, la funci√≥n deber√≠a de devolver los siguientes resultados\n\nPara start_value\n[1] 23653\n\n\n\nPara end_value\n[1] 44141\n\n\n\nü§î¬øQu√© significa esta expresi√≥n?\n\nTanto start_v como end_v son nombres que hemos asignado a la posici√≥n espec√≠ficas del texto. En s√≠, no significan nada. Solo decimos, a trav√©s de ‚Äú&lt;-‚Äù que dichos nombres albergan una funci√≥n de posicionamiento.\nLas funciones del paquete stringi: stri_locate_first_fixed y stri_locate_last_fixed buscan y encuentran la primera coincidencia del valor entrecomillado que precede a nuestro objeto data_char_NALVANY\nEl [1] es un indicador que le estamos dando a la funci√≥n para que escoja la primera posici√≥n donde aparezca el texto que hayamos escogido.\nAs√≠, cuando vemos devuelto las respuestas [1] 23653 y [1] 44141 quiere decir que para start_v y end_v est√° asignado el primer valor donde aparece dichas expresiones , localizadas por primera vez en la posici√≥n 23653 y 44141 de nuestro texto.\n\n\n\nPASO 2, creando nuestro objeto\nCreado nuestro punto de inicio y final de nuestra zona de trabajo, haremos un objeto que alberge dicho rango. Lo llamaremos: diary_v\n\ndiary_v &lt;- stri_sub(data_char_NALVANY, start_v, end_v)\nlength(diary_v)\n\nAl iniciar el c√≥digo el valor que os ha tenido que recuperar, adem√°s de almacenar el objeto en la pesta√±a Environment de RStuido, es:\n[1] 1\n\n\nü§î¬øQu√© significa esta expresi√≥n?\n\ndiary_v es el nombre del objeto que almacena la funci√≥n que ha sido asignada. En este caso, a trav√©s de stri_sub, estamos extrayendo una parte del texto data_char_NALVANY . A diferencia del caso anterior, aqu√≠ le estamos pidiendo que, en vez de que recuper un n√∫mero detemrinado de caracteres, escoja todos los que hay comprendidos entre las posiciones que hemos dado a start_v y a end_v. Con esto nos aseguramos que el objeto diary_v siempre trabaje en los rangos que nos interesa analizar.\nlegth(diary_v) es una expresi√≥n que usamos para comprobar cuandos valores existen en nuestro objeto. Es una forma de asegurarnos de que nuestro objeto solo tiene un vector y no es un conjunto de fragmentos de texto. Por eso, al introducirlo, el programa nos devuelve el valor 1 porque solo hay 1 valor dentro de nuestro objeto.\n\n¬øSab√≠as qu√©‚Ä¶? Ô∏èü§ì‚òù\n\n[3] El paquete stringi es una herramienta muy versatil para el manejo y procesamiento de cadenas de texto. Hemos visto como puede hacer b√∫squedas de posicionamiento, pero tambi√©n puede servir para realizar operciones relacionadas con la manipulaci√≥n de texto: ya sea para remplazar partes del mismo, verificar un formato o pasar de un c√≥digo a otro."
  },
  {
    "objectID": "dataprocessing.html#a-la-tokenizaci√≥n",
    "href": "dataprocessing.html#a-la-tokenizaci√≥n",
    "title": "Carga y procesamiento de textos",
    "section": "üóø ¬°A la tokenizaci√≥n!",
    "text": "üóø ¬°A la tokenizaci√≥n!\nRealizada la limpieza de datos, es hora de preparar nuestro material para convertirlo en un objeto analizable. Para ello haremos tres cosas:\n\nConvertiremos todo el texto almacenado en diary_v en tokens.\nPasaremos toda la informaci√≥n a min√∫sculas mediante la funci√≥n tolower()\nEliminaremos los signos de puntuaci√≥n con la funci√≥n remove_punct=TRUE\n\n\nPASO 1: tokenizaci√≥n\nPara que el programa pueda analizar y realizar manipulaciones sobre las palabras de forma individualizada, vamos a convertir a cada una de ellas en peque√±os valores que llamamos tokens.\nLa funci√≥n tokens() del paquete quanteda es el que nos ayudar√° a realizar este trabajo.\n\ndiary_v_toks &lt;- tokens(diary_v)\n\n\n\nü§î¬øQu√© significa esta expresi√≥n?\nHemos creado un nuevo objeto: diary_v_toks donde los valores que tiene asignado han sido convertidos en una unidad manipulable llamado token. Esto nos permitir√° poder realizar los dos pasos siguientes.\n\n\nPASO 2: eliminaci√≥n de las may√∫sculas.\nR es sensible a las may√∫sculas y las toma como valor diferente a como ser√≠a en min√∫sculas. Por eso, para evitar errores, vamos a homogenizar el texto para que todo est√© en un solo formato: min√∫sculas.\nPara ello crearemos un nuevo objeto: diary_v_toks_lower que albergar√° los valores del objeto del paso anterior, pero con la funci√≥n min√∫sculas aplicadas\n\ndiary_v_toks_lower &lt;- tokens_tolower(diary_v_toks)\n\n\n\nPASO 3: eliminaci√≥n de los signos de puntuaci√≥n.\nEn nuestro texto, habr√° palabras que vengan unidas a un signo de puntuaci√≥n. Las comas, comillas y puntos pueden provocar que el programa identifica una misma palabra: nalvany y nalvany. como dos elementos distintos, lo que podr√≠a darnos un recuento distinto cuando hagamos b√∫squeda de patrones[4].\nPara realizar esta limpieza se har√° un nuevo objeto que llamaremos nalvany_word_v\n\n nalvany_word_v &lt;- tokens(diary_v_toks_lower, remove_punct = TRUE)\n\n\n\nü§î¬øQu√© significa esta expresi√≥n?\n\nDe nuevo el valor nalvany_word_v es un objeto al que se ha aplicado la funci√≥n tokens. Lo que le estamos diciendo a R es que el valor ya tokenizado diary_v_toks_lower vuelva a procesarlo tomando como par√°metro el valor remove_punct=TRUE\nremove_punct=TRUE es el argumento que indica a tokens() que elimine toda la puntuaci√≥n del valor que le antecede, en este caso diary_v_toks_lower.\n\n\n\nüîç Comprobaciones\nUna vez hecho esta re-tokenizaci√≥n, vamos a crear un objeto que contenga la unidad total de valores que tiene el objeto nalvany_word_v . Esto nos ayudar√° a tener una idea total de la longitud del contenido, tambi√©n nos dar√° una idea de cu√°nto se ha reducido el texto al quitar caracteres y nos ahorrar√° tiempo para no tener que calcularlo cuando lo necesitemos\nAplicaremos la funci√≥n ntoken para averiguar la extensi√≥n total de nuestro texto.\n\ntotal_lenght &lt;- ntoken(nalvany_word_v)\n\ntext1 \n 3697 #Nos tendr√≠a que devolver este valor\n¬øSab√≠as qu√©‚Ä¶? Ô∏èü§ì‚òù\n\n[4] En ingl√©s, es posible que el texto venga acompa√±ado de ap√≥strofes como en los casos de don't y he's. Aqu√≠, quanteda no tomar√° las 't ni las 's como elementos aislados, sino que lo mantendr√° unida a la palabra para respetar el significado original."
  }
]