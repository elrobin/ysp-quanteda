<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Carga y procesamiento de textos ‚Äì Introducci√≥n al an√°lisis de textos con Quanteda | YoSigo UGR</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Introducci√≥n al an√°lisis de textos con Quanteda | YoSigo UGR</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ysp_tutorial.html"> 
<span class="menu-text">An√°lisis de textos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./dataprocessing.html" aria-current="page"> 
<span class="menu-text">Carga y procesamiento de textos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./dataviz.html"> 
<span class="menu-text">An√°lisis y visualizaci√≥n de datos</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">√çndice</h2>
   
  <ul>
  <li><a href="#preparando-los-paquetes" id="toc-preparando-los-paquetes" class="nav-link active" data-scroll-target="#preparando-los-paquetes">üì¶Preparando los paquetes</a>
  <ul>
  <li><a href="#por-qu√©-lo-usamos" id="toc-por-qu√©-lo-usamos" class="nav-link" data-scroll-target="#por-qu√©-lo-usamos">¬øPor qu√© lo usamos?</a></li>
  </ul></li>
  <li><a href="#importaci√≥n-de-datos-de-texto" id="toc-importaci√≥n-de-datos-de-texto" class="nav-link" data-scroll-target="#importaci√≥n-de-datos-de-texto">üìÑ‚û°Ô∏èüñ•Ô∏èImportaci√≥n de datos de texto</a>
  <ul>
  <li><a href="#comprobaciones" id="toc-comprobaciones" class="nav-link" data-scroll-target="#comprobaciones">üîç Comprobaciones</a></li>
  </ul></li>
  <li><a href="#acotando-el-texto-a-analizar" id="toc-acotando-el-texto-a-analizar" class="nav-link" data-scroll-target="#acotando-el-texto-a-analizar">üóÉÔ∏èAcotando el texto a analizar</a>
  <ul>
  <li><a href="#paso-1-identificaci√≥n-de-comienzo-y-fin-del-texto" id="toc-paso-1-identificaci√≥n-de-comienzo-y-fin-del-texto" class="nav-link" data-scroll-target="#paso-1-identificaci√≥n-de-comienzo-y-fin-del-texto">PASO 1: Identificaci√≥n de comienzo y fin del texto</a></li>
  <li><a href="#paso-2-nuevo-objeto" id="toc-paso-2-nuevo-objeto" class="nav-link" data-scroll-target="#paso-2-nuevo-objeto">PASO 2: Nuevo objeto</a></li>
  </ul></li>
  <li><a href="#limpiando-datos" id="toc-limpiando-datos" class="nav-link" data-scroll-target="#limpiando-datos">üóëÔ∏è Limpiando datos</a>
  <ul>
  <li><a href="#paso-1-comprobar-la-estructura-del-texto" id="toc-paso-1-comprobar-la-estructura-del-texto" class="nav-link" data-scroll-target="#paso-1-comprobar-la-estructura-del-texto">PASO 1: Comprobar la estructura del texto</a></li>
  <li><a href="#paso-2-conversi√≥n-del-texto-en-vectores" id="toc-paso-2-conversi√≥n-del-texto-en-vectores" class="nav-link" data-scroll-target="#paso-2-conversi√≥n-del-texto-en-vectores">PASO 2: Conversi√≥n del texto en vectores</a></li>
  <li><a href="#paso-3-creaci√≥n-de-√≠ndices-para-identificar-entradas" id="toc-paso-3-creaci√≥n-de-√≠ndices-para-identificar-entradas" class="nav-link" data-scroll-target="#paso-3-creaci√≥n-de-√≠ndices-para-identificar-entradas">PASO 3: Creaci√≥n de √≠ndices para identificar entradas</a></li>
  <li><a href="#paso-4-creaci√≥n-de-entradas-del-diario" id="toc-paso-4-creaci√≥n-de-entradas-del-diario" class="nav-link" data-scroll-target="#paso-4-creaci√≥n-de-entradas-del-diario">PASO 4: Creaci√≥n de entradas del diario</a></li>
  </ul></li>
  <li><a href="#a-la-tokenizaci√≥n" id="toc-a-la-tokenizaci√≥n" class="nav-link" data-scroll-target="#a-la-tokenizaci√≥n">üóø ¬°A la tokenizaci√≥n!</a>
  <ul>
  <li><a href="#paso-1-texto-en-min√∫scula-y-puntuaci√≥n-fuera" id="toc-paso-1-texto-en-min√∫scula-y-puntuaci√≥n-fuera" class="nav-link" data-scroll-target="#paso-1-texto-en-min√∫scula-y-puntuaci√≥n-fuera">PASO 1: Texto en min√∫scula y puntuaci√≥n fuera</a></li>
  <li><a href="#paso-2-tokenizaci√≥n" id="toc-paso-2-tokenizaci√≥n" class="nav-link" data-scroll-target="#paso-2-tokenizaci√≥n">PASO 2: Tokenizaci√≥n</a></li>
  <li><a href="#paso-3-eliminaci√≥n-de-palabras-vac√≠as" id="toc-paso-3-eliminaci√≥n-de-palabras-vac√≠as" class="nav-link" data-scroll-target="#paso-3-eliminaci√≥n-de-palabras-vac√≠as">PASO 3: Eliminaci√≥n de palabras vac√≠as</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Carga y procesamiento de textos</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="preparando-los-paquetes" class="level2">
<h2 class="anchored" data-anchor-id="preparando-los-paquetes">üì¶Preparando los paquetes</h2>
<p>Para seguir este tutorial por primera vez, deber√°s instalar una serie de paquetes<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> que emplearemos: <code>quanteda</code>, <code>readtext</code>, <code>dplyr</code> y <code>stringr</code>. Esto se hace a trav√©s del comando: <code>install.packages()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="fu">c</span>(<span class="st">"quanteda"</span>, <span class="st">"readtext"</span>, <span class="st">"dplyr"</span>, <span class="st">"stringi"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="por-qu√©-lo-usamos" class="level4">
<h4 class="anchored" data-anchor-id="por-qu√©-lo-usamos">¬øPor qu√© lo usamos?</h4>
<dl>
<dt><code>quanteda</code></dt>
<dd>
<p>Paquete de an√°lisis de textos, incluyendo tokenizaci√≥n, conteo y limpieza de textos</p>
</dd>
<dt><code>readtext</code></dt>
<dd>
<p>Permite importar archivos de texto en varios formatos, facilitando la carga de datos</p>
</dd>
<dt><code>dplyr</code></dt>
<dd>
<p>Herramienta para manipulaci√≥n y transformaci√≥n de datos, √∫til para filtrar y organizar datos</p>
</dd>
<dt><code>stringi</code></dt>
<dd>
<p>Conjunto de funciones para trabajar con texto, especialmente √∫til para limpieza y manejo de expresiones regulares.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
</dd>
</dl>
<p><strong>¬øSab√≠as qu√©‚Ä¶?</strong> Ô∏èü§ì‚òù</p>
<div class="tip" style="background-color: #A8E6A1; border-left: 5px solid #A8E6A1; padding: 10px">
<p>La <strong>tokenizaci√≥n</strong> es el proceso de dividir un texto en unidades m√°s peque√±as llamdas <em>tokens</em>. Estas unidades pueden ser palabras, s√≠mbolos, frases o incluso caracteres dependiendo del tipo de an√°lisis que se vaya a realizar. En <code>quanteda</code> consideramos la palabra como la unidad m√≠nima de trabajo. Imag√≠nate que tienes la siguiente oraci√≥n:</p>
<p>‚ÄúHola, ¬øc√≥mo est√°s?‚Äù</p>
<p>La tokenizaci√≥n de esta frase podr√≠a dar como resultado los siguientes tokens: ‚ÄúHola‚Äù, ‚Äú¬ø‚Äù, ‚Äúc√≥mo‚Äù, ‚Äúest√°s‚Äù, ‚Äú?‚Äù</p>
<p>Esto es especialmente √∫til cuando estamos trabajando con estudios relacionados con frecuencias de palabras.</p>
</div>
</section>
</section>
<section id="importaci√≥n-de-datos-de-texto" class="level2">
<h2 class="anchored" data-anchor-id="importaci√≥n-de-datos-de-texto">üìÑ‚û°Ô∏èüñ•Ô∏èImportaci√≥n de datos de texto</h2>
<p>Vamos a vincular el archivo de&nbsp;texto en la aplicaci√≥n de RStudios. Para ello vamos a cargar los paquetes que hemos instalado anteriormente&nbsp;con el comando <code>library("name")</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(quanteda)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readtext)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringi)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Es importante resaltar que, si no llamamos antes el paquete, los comandos que introduzcamos despu√©s no funcionar√°n o nos dar√°n error. Aseg√∫rate de cargar siempre la librer√≠a antes de empezar a trabajar.</p>
<p>Una vez cargados, el programa estar√° listo para leer nuestro archivo de texto. La formula que vamos a escribir para decirle a <code>quanteda</code> que archivo analizar ser√° el siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>navalny_raw <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="fu">readtext</span>(<span class="st">"NAVALNY.txt"</span>))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(navalny_raw) <span class="ot">&lt;-</span> <span class="st">"navalny"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>‚ùóATENCI√ìN:</strong> Si por alguna raz√≥n hiciesemos alg√∫n cambio en el contenido del archivo, deberemos de aplicar el paso anterior de nuevo. Cuando cargamos un archivo en R, se guarda una copia y cualquier cambio en el original no se refleja autom√°ticamente.</p>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<p>Este comando carga el archivo <code>NAVALNY.txt</code> en el objeto <code>navalny_raw</code>, el cual contiene el contenido del texto. Vamos a desgranar este prompt para que pueda entenderse m√°s facil:</p>
<ul>
<li><p><code>navalny_raw</code> es un objeto en R que almacena el texto como una cadena de caracteres (character vector). En <code>R</code> hablamos de <strong>objetos</strong> para referirnos a los contenedores donde almacenamos datos e informaci√≥n. En el caso anterior, el objeto <code>data_char_navalny</code> almacena el texto plano que vamos a utilizar. Existen distintos objetos con diferentes datos almacenados: matrices, n√∫meros, listas jerarquizadas, as√≠ como un sin fin de combinaciones. A lo largo de este caso pr√°ctico trabajaremos con ellos para gestionar m√°s facilmente el an√°lisis cuantitativo.</p></li>
<li><p><code>&lt;-</code> emula a una flecha y b√°sicamente indica la direcci√≥n de la acci√≥n. Al objeto <code>navalny_raw</code> estamos aplic√°ndole una funci√≥n</p></li>
<li><p><code>as.character()</code>: Se trata de la funci√≥n que estamos aplicando. Esta funci√≥n convierte todo lo que se contiene dentro de ella en car√°cter. En <code>R</code> toda funci√≥n viene seguida por unos par√©ntesis dentro de los cu√°les se incluyen los par√°metros de dicha funci√≥n. Si no hay contenido, se aplican los par√°metros que la funci√≥n trae por defecto.</p></li>
<li><p><code>readtext</code>: Aqu√≠ estamos empleando una funci√≥n expec√≠fica del paquete <code>readtext</code>. Si no hubi√©semos cargado el paquete anteriormente, podr√≠amos invocarlo espec√≠ficamente para activar esta funci√≥n con la notaci√≥n <code>paquete::funci√≥n</code>. Aqu√≠, lo que le estamos diciendo a RStudio es que, del paquete <code>readtext</code>, aplique espec√≠ficamente la funci√≥n lectura que casualmente tambi√©n se llama <code>readtext</code> . Dentro indicamos entrecomillada la ruta del archivo a importar. Un <strong>problema muy com√∫n</strong> que puede surgir a la hora de introducir la URL de la ubicaci√≥n del archivo es expresarlo con barras laterales izquierdas ‚Äù \ ‚Äú, tal y como viene en la barra de direcci√≥n del explorador de archivos de Windows, en vez de la derecha‚Äù / ‚Äú. Si tienes problemas leer tu .txt ¬°prueba con hacer este cambio!</p></li>
<li><p><code>names(navalny_raw) &lt;- "navalny"</code>: Asigna un nombre al objeto que contiene el texto, facilitando su identificaci√≥n en futuros an√°lisis.</p></li>
</ul>
<section id="comprobaciones" class="level4">
<h4 class="anchored" data-anchor-id="comprobaciones">üîç Comprobaciones</h4>
<p>En el an√°lisis cuantitativo toda precauci√≥n es poca. Vamos a verificar que el texto ha sido le√≠do por el programa. Usaremos el paquete <code>stringi</code> para ver los primeros 75 caracteres de nuestro archivo y confirmar que los datos se cargaron bien.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Comprobar los primeros 75 caracteres del texto</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">stri_sub</span>(navalny_raw, <span class="dv">1</span>, <span class="dv">75</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2022\nJanuary 17th\nExactly one year ago today I came home, to Russia.\nI didn"</code></pre>
</div>
</div>
<p>Si hemos hecho los pasos bien, tendr√©is que haber recibir este texto de vuelta:</p>
<pre><code>[1] "2022\nJanuary 17th\nExactly one year ago today I came home, to Russia.\nI didn"</code></pre>
</section>
</section>
<section id="acotando-el-texto-a-analizar" class="level2">
<h2 class="anchored" data-anchor-id="acotando-el-texto-a-analizar">üóÉÔ∏èAcotando el texto a analizar</h2>
<p>Nuestro siguiente objetivo es seleccionar qu√© partes del texto vamos aplicar el an√°lisis cuantitativo. Puede que nuestro foco de inter√©s sea algun apartado concreto de nuestro material, por lo que vamos a crear un objeto que albergue un rango determinado dentro de nuestro fichero <code>txt</code> . Con esto, nos quitaremos toda la informaci√≥n innecesaria que puede ensuciar nuestros resultados.</p>
<p>El proceso que vamos a realizar a continuaci√≥n es muy √∫til cuando los archivos que manejamos tienen ligados metadatos. Normalmente, esta metadata suele ser m√°s un dolor de cabeza que otra cosa y es recomendable realizar una limpieza previa para que esos datos no se mezclen con el contenido de nuestro an√°lisis. En este apartado seguiremos trabajando con el paquete <code>stringi</code>.</p>
<p>Si el texto contiene secciones que no necesitamos para el an√°lisis, podemos filtrarlas o limpiarlas en esta etapa.</p>
<section id="paso-1-identificaci√≥n-de-comienzo-y-fin-del-texto" class="level4">
<h4 class="anchored" data-anchor-id="paso-1-identificaci√≥n-de-comienzo-y-fin-del-texto">PASO 1: Identificaci√≥n de comienzo y fin del texto</h4>
<p>Para crear el objeto que albergue el rango de texto a analizar deberemos empezar indicando donde empieza y termina nuestra selecci√≥n. Para ello, crearemos dos valores de posici√≥n: <code>start_v</code> y <code>end_v</code>, donde <code>start_</code> ser√°: ‚Äú2023, January 12th‚Äù y <code>end_v</code> ‚ÄúAlexei Navalny died‚Äù.</p>
<p>Localizado el rango que queremos, la forma de expresarlo en el programa ser√≠a el siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(start_v <span class="ot">&lt;-</span> <span class="fu">stri_locate_first_fixed</span>(navalny_raw, <span class="st">"2023</span><span class="sc">\n</span><span class="st">January 12th"</span>)[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 23654</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(end_v <span class="ot">&lt;-</span> <span class="fu">stri_locate_last_fixed</span>(navalny_raw, <span class="st">"Alexei Navalny died"</span>)[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 44099</code></pre>
</div>
</div>
<p>Si lo hemos aplicado bien, la funci√≥n deber√≠a de devolver los siguientes resultados</p>
<ul>
<li><p>Para <code>start_value</code></p>
<pre><code>[1] 23653</code></pre></li>
</ul>
<!-- -->
<ul>
<li><p>Para <code>end_value</code></p>
<pre><code>[1] 44099</code></pre></li>
</ul>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li><p>Tanto <code>start_v</code> como <code>end_v</code> son nombres que hemos asignado a la posici√≥n espec√≠ficas del texto. En s√≠, no significan nada. Solo decimos, a trav√©s de ‚Äú&lt;-‚Äù que dichos nombres albergan una funci√≥n de posicionamiento.</p></li>
<li><p>Las funciones del paquete <code>stringi</code>: <code>stri_locate_first_fixed</code> y <code>stri_locate_last_fixed</code> buscan y encuentran la primera coincidencia del valor entrecomillado que precede a nuestro objeto <code>data_char_NALVANY</code></p></li>
<li><p>El [1] es un indicador que le estamos dando a la funci√≥n para que escoja la primera posici√≥n donde aparezca el texto que hayamos escogido.</p></li>
<li><p>As√≠, cuando vemos devuelto las respuestas <code>[1] 23653</code> y <code>[1] 44141</code> quiere decir que para <code>start_v</code> y <code>end_v</code> est√° asignado el primer valor donde aparece dichas expresiones , localizadas por primera vez en la posici√≥n 23653 y 44141 de nuestro texto.</p></li>
</ul>
</section>
<section id="paso-2-nuevo-objeto" class="level4">
<h4 class="anchored" data-anchor-id="paso-2-nuevo-objeto">PASO 2: Nuevo objeto</h4>
<p>Creado nuestro punto de inicio y final de nuestra zona de trabajo, haremos un objeto que alberge dicho rango. Lo llamaremos: <code>navalny_fix</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>navalny_fix <span class="ot">&lt;-</span> <span class="fu">stri_sub</span>(navalny_raw, start_v, end_v)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(navalny_fix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>Al iniciar el c√≥digo el valor que os ha tenido que recuperar, adem√°s de almacenar el objeto en la pesta√±a <code>Environment</code> de RStuido, es:</p>
<pre><code>[1] 1</code></pre>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li><p><code>navalny_fix</code> es el nombre del objeto que almacena la funci√≥n que ha sido asignada. En este caso, a trav√©s de <code>stri_sub</code>, estamos extrayendo una parte del texto <code>navalny_fix</code> . A diferencia del caso anterior, aqu√≠ le estamos pidiendo que, en vez de que recuper un n√∫mero detemrinado de caracteres, escoja todos los que hay comprendidos entre las posiciones que hemos dado a <code>start_v</code> y a <code>end_v</code>. Con esto nos aseguramos que el objeto <code>navalny_fix</code> siempre trabaje en los rangos que nos interesa analizar.</p></li>
<li><p><code>length(navalny_fix)</code> es una expresi√≥n que usamos para comprobar cuandos valores existen en nuestro objeto. Es una forma de asegurarnos de que nuestro objeto solo tiene un vector y no es un conjunto de fragmentos de texto. Por eso, al introducirlo, el programa nos devuelve el valor 1 porque solo hay 1 valor dentro de nuestro objeto.</p></li>
</ul>
</section>
</section>
<section id="limpiando-datos" class="level2">
<h2 class="anchored" data-anchor-id="limpiando-datos">üóëÔ∏è Limpiando datos</h2>
<p>Ya tenemos nuestro set de datos, nos toca empezar a limpiar antes de tokenizar y empezar a analizar.</p>
<section id="paso-1-comprobar-la-estructura-del-texto" class="level4">
<h4 class="anchored" data-anchor-id="paso-1-comprobar-la-estructura-del-texto">PASO 1: Comprobar la estructura del texto</h4>
<p>Vamos a abrir un momento nuestro archivo para ver lo que contiene. Aqu√≠ te ense√±o las primeras l√≠neas:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>2023
January 12th
In my two years behind bars, my only truly original story is the one about the
psycho. Everything else has been told and described numerous times. If you
open any book by a Soviet dissident, there will be endless stories of punishment
cells, hunger strikes, violence, provocations, lack of medical care. Nothing new.
But my story about the psycho is fresh; at least,I‚Äôve never seen or heard
anything like it

So, let me give you an idea about the shizo, the place where I sit all the time. It
is a narrow corridor with cells on either side. The metal doors offer little to no
soundproofing, plus there are ventilation holes above the doors, so two people
sitting in opposite cells can have a conversation without even raising their
voices. This is the main reason there has never been anyone in the cell opposite
mine, or in my entire eight-cell section. I am the only one there, and I have</code></pre>
</div>
</div>
<p>Aqu√≠ queda m√°s clara la estructura del texto:</p>
<ul>
<li><p>Cada entrada del diario empieza con el a√±o en la primera l√≠nea</p></li>
<li><p>Dentro de cada a√±o, se dividen por d√≠as las entradas</p></li>
<li><p>Los p√°rrafos est√°n separados por saltos de l√≠nea</p></li>
<li><p>Las entradas est√°n separadas entre s√≠ tambi√©n por una linea en blanco.</p></li>
</ul>
<p>A continuaci√≥n lo que vamos a hacer es crear un objeto lista<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, en la que cada elemento ser√° una entrada del diario.</p>
</section>
<section id="paso-2-conversi√≥n-del-texto-en-vectores" class="level4">
<h4 class="anchored" data-anchor-id="paso-2-conversi√≥n-del-texto-en-vectores">PASO 2: Conversi√≥n del texto en vectores</h4>
<p>Ahora que comprendemos la estructura, vamos a separar el texto en entradas diarias, preservando la estructura de p√°rrafos dentro de cada entrada. Primero dividimos el texto en l√≠neas, donde cada l√≠nea se convierte en un elemento de un vector. Esto nos permite identificar las lineas que contienen fechas y separar las entradas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convertir el texto en un vector de l√≠neas</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>lines <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">strsplit</span>(navalny_fix, <span class="st">'</span><span class="sc">\n</span><span class="st">'</span>)) <span class="co"># \n indica un salto de l√≠nea</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li><p><code>strsplit()</code> divide el texto por saltos de l√≠nea (<code>"\n"</code>), creando un vector en el que cada l√≠nea es un elemento independiente.</p></li>
<li><p>Usamos <code>unlist()</code> para simplificar la estructura y trabajar con un vector plano.</p></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(lines) <span class="co"># Veamos las primeras seis l√≠neas de nuestro objeto</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2023"                                                                             
[2] "January 12th"                                                                     
[3] "In my two years behind bars, my only truly original story is the one about the"   
[4] "psycho. Everything else has been told and described numerous times. If you"       
[5] "open any book by a Soviet dissident, there will be endless stories of punishment" 
[6] "cells, hunger strikes, violence, provocations, lack of medical care. Nothing new."</code></pre>
</div>
</div>
</section>
<section id="paso-3-creaci√≥n-de-√≠ndices-para-identificar-entradas" class="level4">
<h4 class="anchored" data-anchor-id="paso-3-creaci√≥n-de-√≠ndices-para-identificar-entradas">PASO 3: Creaci√≥n de √≠ndices para identificar entradas</h4>
<p>En este paso, vamos a crear los <strong>√≠ndices</strong> que nos permitir√°n identificar las l√≠neas en el texto que corresponden a cada a√±o y a cada d√≠a. Esto nos ayudar√° a estructurar las entradas en el pr√≥ximo paso.</p>
<ol type="1">
<li>Utilizando expresiones regulares, vamos a identificar las l√≠neas que contengan s√≥lo el a√±o. Estas l√≠neas marcan el inicio de cada conjunto de entradas anuales</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>year_indices <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">"^</span><span class="sc">\\</span><span class="st">d{4}$"</span>, lines)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(year_indices) <span class="co"># Muestra las l√≠neas que contienen el a√±o</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]   1 295</code></pre>
</div>
</div>
<ol start="2" type="1">
<li>Hemos identificado dos l√≠neas que incluyen el a√±o. Ahora haremos lo mismo para las l√≠neas que encuentren el mes y el d√≠a</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>day_indices <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">"^(January|February|March|April|May|June|July|August|September|October|November|December)</span><span class="sc">\\</span><span class="st">s+</span><span class="sc">\\</span><span class="st">d{1,2}(st|nd|rd|th)?$"</span>, lines)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(day_indices) <span class="co"># N√∫mero de entradas identificadas</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 11</code></pre>
</div>
</div>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li><p><code>year_indices</code> contiene los √≠ndices de las l√≠neas con los a√±os, es decir, las posiciones donde comienza cada a√±o en el texto. La expresi√≥n regular <code>^\\d{4}</code> busca cuatro d√≠gitos al inicio de la l√≠nea.</p></li>
<li><p><code>month_day_indices</code> contiene los √≠ndices de las l√≠neas con fechas diarias, indicando el inicio de cada d√≠a dentro de los a√±os.</p>
<ul>
<li><p><code>(January|February|...)</code>: Busca un mes escrito en ingl√©s.</p></li>
<li><p><code>\\s+</code>: Representa uno o m√°s espacios.</p></li>
<li><p><code>\\d{1,2}(st|nd|rd|th)?$</code>: Busca el d√≠a, que tendr√° uno o dos d√≠gitos y que puede ir seguido de ‚Äúst‚Äù, ‚Äúnd‚Äù, ‚Äúrd‚Äù, o ‚Äúth‚Äù al final de la l√≠nea.</p></li>
</ul></li>
</ul>
</section>
<section id="paso-4-creaci√≥n-de-entradas-del-diario" class="level4">
<h4 class="anchored" data-anchor-id="paso-4-creaci√≥n-de-entradas-del-diario">PASO 4: Creaci√≥n de entradas del diario</h4>
<p>Ahora que tenemos los √≠ndices para los a√±os y d√≠as, podemos organizar el texto en <strong>entradas anidadas</strong>: cada a√±o ser√° un grupo principal, y dentro de cada a√±o, cada d√≠a ser√° una entrada individual.</p>
<p>El siguiente c√≥digo es un poco tocho, te intento explicar:</p>
<ol type="1">
<li>Creamos las entradas por a√±o. Para esto utilizamos el objeto <code>year_indices</code> que construimos antes.</li>
<li>Creamos sublistas dentro de cada a√±o con nuestro objeto <code>month_day_indices</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Dividimos el texto en entradas anidadas (por a√±o y d√≠a)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">seq_along</span>(year_indices), </span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">function</span>(i) {</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    start_year <span class="ot">&lt;-</span> year_indices[i]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    end_year <span class="ot">&lt;-</span> <span class="cf">if</span> (i <span class="sc">&lt;</span> <span class="fu">length</span>(year_indices))</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      year_indices[i <span class="sc">+</span> <span class="dv">1</span>] <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">length</span>(lines)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extraemos las l√≠neas correspondientes al a√±o actual</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    year_lines <span class="ot">&lt;-</span> lines[start_year<span class="sc">:</span>end_year]</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Encontrar las entradas diarias dentro del a√±o actual</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    day_indices <span class="ot">&lt;-</span> <span class="fu">grep</span>(</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>      <span class="st">"^(January|February|March|April|May|June|July|August|September|October|November|December)</span><span class="sc">\\</span><span class="st">s+</span><span class="sc">\\</span><span class="st">d{1,2}(st|nd|rd|th)?$"</span>,</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>      year_lines</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Crear una sublista para cada d√≠a dentro del a√±o</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="fu">seq_along</span>(day_indices), <span class="cf">function</span>(j) {</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>      start_day <span class="ot">&lt;-</span> day_indices[j]</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>      end_day <span class="ot">&lt;-</span> <span class="cf">if</span> (j <span class="sc">&lt;</span> <span class="fu">length</span>(day_indices))</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>        day_indices[j <span class="sc">+</span> <span class="dv">1</span>] <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">length</span>(year_lines)</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>      year_lines[start_day<span class="sc">:</span>end_day]</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>      })</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Devolver una lista con el a√±o y sus entradas diarias</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list</span>(<span class="at">year =</span> year_lines[<span class="dv">1</span>], <span class="at">entries =</span> entries)</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li><p>Cada elemento en <code>yearly_entries</code> es un a√±o completo</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(yearly_entries[[<span class="dv">1</span>]]<span class="sc">$</span>year) <span class="co"># primer a√±o</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2023"</code></pre>
</div>
</div></li>
<li><p>Dentro de cada a√±o, <code>entries</code> contiene las entradas diarias como sublistas, donde cada d√≠a es un vector de p√°rrafos</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(yearly_entries[[<span class="dv">1</span>]]<span class="sc">$</span>entries)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 9</code></pre>
</div>
</div></li>
</ul>
<p>Para ello, hemos combinado diferentes funciones en un s√≥lo script:</p>
<ul>
<li><p><code>lapply()</code> sirve para aplicar una funci√≥n a cada elemento de un vector o lista. En nuestro caso, itera sobre cada √≠ndice de <code>year_indices</code>, procesando el texto correspondiente a cada √±o. Genera una lista <code>yearly_indices</code>donde cada elemento representa un a√±o y sus entradas diarias. La segunda vez que la empleo es para crear sublistas para cada d√≠a dentro del a√±o, aplic√°ndola sobre <code>day_indices</code>.</p></li>
<li><p><code>seq_along()</code> genera una secuencia de n√∫meros que corresponden a la longitud de un vector o lista. Lo utilizo para generar una secuencia de √≠ndices a iterar sobre los a√±os y sobre los d√≠as dentro de cada a√±o.</p></li>
<li><p><code>grep()</code> busca patrones espec√≠ficos dentro de un vector, tal y como hicimos antes.</p></li>
<li><p><code>if</code>dentro de <code>lapply()</code>define los l√≠mites de inicio y fin de cada a√±o.</p></li>
<li><p><code>list()</code> crea la lista que almacena todas las entradas.</p></li>
</ul>
</section>
</section>
<section id="a-la-tokenizaci√≥n" class="level2">
<h2 class="anchored" data-anchor-id="a-la-tokenizaci√≥n">üóø ¬°A la tokenizaci√≥n!</h2>
<p>Ya tenemos nuestro texto bien organizado y estructurado. Toca dividir a√∫n m√°s y limpiar. Para ello vamos a hacer lo siguiente:</p>
<ol type="1">
<li>Convertimos el texto en min√∫sculas y eliminaos los signos de puntuaci√≥n</li>
<li>Tokenizamos el texto dividi√©ndolo en palabras. De manera que nuestra unidad de an√°lisis ser√° la palabra<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</li>
<li>Eliminamos todas las palabras vac√≠as<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> para quedarnos s√≥lo con aquellas relevantes para nuestro an√°lisis.</li>
</ol>
<section id="paso-1-texto-en-min√∫scula-y-puntuaci√≥n-fuera" class="level4">
<h4 class="anchored" data-anchor-id="paso-1-texto-en-min√∫scula-y-puntuaci√≥n-fuera">PASO 1: Texto en min√∫scula y puntuaci√≥n fuera</h4>
<p>Para asegurarnos que palabras id√©nticas no se traten como diferentes por su formato, converitmos todo el texto a min√∫sculas y eliminamos puntuaci√≥n.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convertir cada entrada diaria a min√∫sculas y eliminar signos de puntuaci√≥n</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(yearly_entries, <span class="cf">function</span>(year) {</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  year<span class="sc">$</span>entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(year<span class="sc">$</span>entries, <span class="cf">function</span>(entry) {</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convertir el texto a min√∫sculas y eliminar puntuaci√≥n</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    entry <span class="ot">&lt;-</span> <span class="fu">char_tolower</span>(entry)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    entry <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="st">"[[:punct:]]"</span>, <span class="st">""</span>, entry)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    entry</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  year  <span class="co"># Devolver la lista de a√±o modificada</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li><p>La funci√≥n <code>char_tolower()</code> convierte el texto en min√∫sculas.</p></li>
<li><p>La funci√≥n <code>gsub()</code> sustituye un patr√≥n de texto por otro. En nuestro caso, le hemos pedido que busque cualquier signo de puntuaci√≥n empleando la expresi√≥n regular <code>[[:punct:]]</code> y la reemplace por nada.</p></li>
<li><p>Despu√©s hemos pedido que incluya estos cambios nuevamente en nuestro objeto <code>yearly_entries</code>.</p></li>
</ul>
<p>Si observas las primeras l√≠neas de una entrada, ver√°s que todo ha funcionado tal y como esper√°bamos:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "january 12th"                                                                   
[2] "in my two years behind bars my only truly original story is the one about the"  
[3] "psycho everything else has been told and described numerous times if you"       
[4] "open any book by a soviet dissident there will be endless stories of punishment"
[5] "cells hunger strikes violence provocations lack of medical care nothing new"    </code></pre>
</div>
</div>
</section>
<section id="paso-2-tokenizaci√≥n" class="level4">
<h4 class="anchored" data-anchor-id="paso-2-tokenizaci√≥n">PASO 2: Tokenizaci√≥n</h4>
<p>Para que el programa pueda analizar y realizar manipulaciones sobre las palabras de forma individualizada, vamos a convertir a cada una de ellas en peque√±os valores que llamamos <strong>tokens.</strong></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tokenizar cada entrada diaria dentro de cada a√±o</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(yearly_entries, <span class="cf">function</span>(year) {</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  year<span class="sc">$</span>entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(year<span class="sc">$</span>entries, <span class="cf">function</span>(entry) {</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">tokens</span>(entry, <span class="at">what =</span> <span class="st">"word"</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  year  <span class="co"># Devolver la lista de a√±o modificada</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li><p>Siguiendo la misma estructura de la vez anterior, hemos incorporado la funci√≥n <code>tokens()</code> y lo hemos aplicado al objeto <code>entry</code></p></li>
<li><p>Adem√°s, hemos utilizado el par√°metro <code>what=</code> en el que indicamos el nivel. En nuestro caso tokenizamos por palabras. Otras opciones son por caracteres (<code>character</code>) y frases (<code>sentence</code>).</p></li>
</ul>
<p>Ahora en lugar de contener un listado de filas por entrada, lo que tengo es una bolsa de palabras:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Tokens consisting of 3 documents.
text1 :
[1] "january" "12th"   

text2 :
 [1] "in"       "my"       "two"      "years"    "behind"   "bars"    
 [7] "my"       "only"     "truly"    "original" "story"    "is"      
[ ... and 4 more ]

text3 :
 [1] "psycho"     "everything" "else"       "has"        "been"      
 [6] "told"       "and"        "described"  "numerous"   "times"     
[11] "if"         "you"       </code></pre>
</div>
</div>
</section>
<section id="paso-3-eliminaci√≥n-de-palabras-vac√≠as" class="level4">
<h4 class="anchored" data-anchor-id="paso-3-eliminaci√≥n-de-palabras-vac√≠as">PASO 3: Eliminaci√≥n de palabras vac√≠as</h4>
<p>Para centrarnos en las palabras significativas, eliminamos las <strong>palabras vac√≠as</strong> (stopwords), que suelen ser t√©rminos comunes y poco informativos, como ‚Äúel‚Äù, ‚Äúde‚Äù, ‚Äúy‚Äù. Esto permite que el an√°lisis se centre en t√©rminos con m√°s contenido sem√°ntico.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Eliminar palabras vac√≠as en ingl√©s en cada entrada diaria</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(yearly_entries, <span class="cf">function</span>(year) {</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  year<span class="sc">$</span>entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(year<span class="sc">$</span>entries, <span class="cf">function</span>(entry) {</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">tokens_remove</span>(entry, <span class="at">pattern =</span> <span class="fu">stopwords</span>(<span class="st">"en"</span>)) </span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  year  <span class="co"># Devolver la lista de a√±o modificada</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>ü§î¬øQu√© hemos hecho?</strong></p>
<ul>
<li>Aqu√≠ empleamos la funci√≥n <code>tokens_remove()</code> otra vez aplicada al objeto <code>entry</code>, en este caso empleamos el par√°metro <code>pattern =</code> para indicar que eliminaremos los tokens que representen palabras vac√≠as, en par√©ntesis incluimos la lengua a trav√©s de su c√≥digo ISO, en nuestro caso el ingl√©s. <a href="https://www.rdocumentation.org/packages/stopwords/versions/2.3">Aqu√≠ tienes el listado completo de idiomas</a>. El paquete <code>stopwords</code> permite asimismo crear y/o a√±adir tus propias palabras vac√≠as.</li>
</ul>
<p>F√≠jate c√≥mo, en comparaci√≥n con el fragmento anterior, se han eliminado palabras como ‚Äúin‚Äù, ‚Äúmy‚Äù u ‚Äúonly‚Äù.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Tokens consisting of 3 documents.
text1 :
[1] "january" "12th"   

text2 :
[1] "two"      "years"    "behind"   "bars"     "truly"    "original" "story"   
[8] "one"     

text3 :
[1] "psycho"     "everything" "else"       "told"       "described" 
[6] "numerous"   "times"     </code></pre>
</div>
</div>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Como habr√°s notado, es posible juntar todos estos pasos en uno s√≥lo. Aqu√≠ lo mostramos por trozos para que vayas comprendiendo el proceso, pero podr√≠amos hacer todo esto de una vez.</p>
</div>
</div>
</div>
<p><strong>¬øSab√≠as qu√©‚Ä¶?</strong> Ô∏èü§ì‚òù</p>
<div class="tip" style="background-color: #A8E6A1; border-left: 5px solid #A8E6A1; padding: 10px">
<p>En ingl√©s, es posible que el texto venga acompa√±ado de ap√≥strofes como en los casos de <code>don't</code> y <code>he's</code>. Aqu√≠, <code>quanteda</code> no tomar√° las <code>'t</code> ni las <code>'s</code> como elementos aislados, sino que lo mantendr√° unida a la palabra para respetar el significado original.</p>
</div>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><code>R</code> es un lenguaje de programaci√≥n abierto y colaborativo que sigue una estructura totalmente descentralizada. Cuando instalamos <code>R</code> por primera vez, s√≥lo instalamos sus funcionalidades b√°sicas. Todas aquellas funcionalidades adicionales llevadas a cabo por terceras personas deben instalarse en lo que se denominan <strong>paquetes</strong> o <strong>libraries</strong> en ingl√©s.</p>
<p>Cada vez que vayas a emplear un paquete, debes cargarlo, por defecto, cada vez que abres <code>R</code> estos paquetes no est√°n cargados.</p>
</div>
</div>
</div>
<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></li>
<li id="fn2"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Una <strong>expresi√≥n regular</strong> es un patr√≥n de b√∫squeda utilizado para manipular texto espec√≠fico en una cadena. Facilita tareas como eliminar caracteres no deseados o extraer informaci√≥n espec√≠fica (e.g., fechas o n√∫meros). Es especialmente √∫til en la limpieza y preprocesamiento de datos textuales.</p>
</div>
</div>
</div>
<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></li>
<li id="fn3"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Una <strong>lista</strong> es una estructura de datos qeu puede contener elementos de diferentes tipos (num√©rico, caract√©res, vectores o incluso otras listas) en un solo objecto. Cada elemento en una lista se puede acceder de forma individual usando √≠ndices. Esto se hace utilizando corchetes dobles. Por ejemplo si queremos ver el segundo elemento de la lista <code>lista</code>, lo indicaremos as√≠: <code>lista[[2]]</code>.</p>
</div>
</div>
</div>
<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></li>
<li id="fn4"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Aqu√≠ es importante diferenciar entre an√°lisis textual y un an√°lisis sem√°ntico. En el an√°lisis de textos examinamos cuestiones como la frecuencia de las palabras, patrones o estructura, sin considerar el significado de cada palabra. Se tratar√≠a de un paso previo al an√°lisis sem√°ntico donde nos centramos en el significado y el contexto de las palabras.</p>
</div>
</div>
</div>
<a href="#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></li>
<li id="fn5"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Las <strong>palabras vac√≠as</strong> son t√©rminos comunes (como ‚Äúel‚Äù, ‚Äúde‚Äù, ‚Äúy‚Äù) que suelen aparecer con mucha frecuencia en el texto, pero aportan poco significado o valor informativo al an√°lisis. Estas palabras se eliminan generalmente para centrar el an√°lisis en los t√©rminos m√°s relevantes.</p>
</div>
</div>
</div>
<a href="#fnref5" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>