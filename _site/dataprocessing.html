<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Carga y procesamiento de textos – Introducción al análisis de textos con Quanteda | YoSigo UGR</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Introducción al análisis de textos con Quanteda | YoSigo UGR</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ysp_tutorial.html"> 
<span class="menu-text">Análisis de textos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./dataprocessing.html" aria-current="page"> 
<span class="menu-text">Carga y procesamiento de textos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./dataviz.html"> 
<span class="menu-text">Análisis y visualización de datos</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Índice</h2>
   
  <ul>
  <li><a href="#preparando-los-paquetes" id="toc-preparando-los-paquetes" class="nav-link active" data-scroll-target="#preparando-los-paquetes">📦Preparando los paquetes</a>
  <ul>
  <li><a href="#por-qué-lo-usamos" id="toc-por-qué-lo-usamos" class="nav-link" data-scroll-target="#por-qué-lo-usamos">¿Por qué lo usamos?</a></li>
  </ul></li>
  <li><a href="#importación-de-datos-de-texto" id="toc-importación-de-datos-de-texto" class="nav-link" data-scroll-target="#importación-de-datos-de-texto">📄➡️🖥️Importación de datos de texto</a>
  <ul>
  <li><a href="#comprobaciones" id="toc-comprobaciones" class="nav-link" data-scroll-target="#comprobaciones">🔍 Comprobaciones</a></li>
  </ul></li>
  <li><a href="#acotando-el-texto-a-analizar" id="toc-acotando-el-texto-a-analizar" class="nav-link" data-scroll-target="#acotando-el-texto-a-analizar">🗃️Acotando el texto a analizar</a>
  <ul>
  <li><a href="#paso-1-identificación-de-comienzo-y-fin-del-texto" id="toc-paso-1-identificación-de-comienzo-y-fin-del-texto" class="nav-link" data-scroll-target="#paso-1-identificación-de-comienzo-y-fin-del-texto">PASO 1: Identificación de comienzo y fin del texto</a></li>
  <li><a href="#paso-2-nuevo-objeto" id="toc-paso-2-nuevo-objeto" class="nav-link" data-scroll-target="#paso-2-nuevo-objeto">PASO 2: Nuevo objeto</a></li>
  </ul></li>
  <li><a href="#limpiando-datos" id="toc-limpiando-datos" class="nav-link" data-scroll-target="#limpiando-datos">🗑️ Limpiando datos</a>
  <ul>
  <li><a href="#paso-1-comprobar-la-estructura-del-texto" id="toc-paso-1-comprobar-la-estructura-del-texto" class="nav-link" data-scroll-target="#paso-1-comprobar-la-estructura-del-texto">PASO 1: Comprobar la estructura del texto</a></li>
  <li><a href="#paso-2-conversión-del-texto-en-vectores" id="toc-paso-2-conversión-del-texto-en-vectores" class="nav-link" data-scroll-target="#paso-2-conversión-del-texto-en-vectores">PASO 2: Conversión del texto en vectores</a></li>
  <li><a href="#paso-3-creación-de-índices-para-identificar-entradas" id="toc-paso-3-creación-de-índices-para-identificar-entradas" class="nav-link" data-scroll-target="#paso-3-creación-de-índices-para-identificar-entradas">PASO 3: Creación de índices para identificar entradas</a></li>
  <li><a href="#paso-4-creación-de-entradas-del-diario" id="toc-paso-4-creación-de-entradas-del-diario" class="nav-link" data-scroll-target="#paso-4-creación-de-entradas-del-diario">PASO 4: Creación de entradas del diario</a></li>
  </ul></li>
  <li><a href="#a-la-tokenización" id="toc-a-la-tokenización" class="nav-link" data-scroll-target="#a-la-tokenización">🗿 ¡A la tokenización!</a>
  <ul>
  <li><a href="#paso-1-texto-en-minúscula-y-puntuación-fuera" id="toc-paso-1-texto-en-minúscula-y-puntuación-fuera" class="nav-link" data-scroll-target="#paso-1-texto-en-minúscula-y-puntuación-fuera">PASO 1: Texto en minúscula y puntuación fuera</a></li>
  <li><a href="#paso-2-tokenización" id="toc-paso-2-tokenización" class="nav-link" data-scroll-target="#paso-2-tokenización">PASO 2: Tokenización</a></li>
  <li><a href="#paso-3-eliminación-de-palabras-vacías" id="toc-paso-3-eliminación-de-palabras-vacías" class="nav-link" data-scroll-target="#paso-3-eliminación-de-palabras-vacías">PASO 3: Eliminación de palabras vacías</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Carga y procesamiento de textos</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="preparando-los-paquetes" class="level2">
<h2 class="anchored" data-anchor-id="preparando-los-paquetes">📦Preparando los paquetes</h2>
<p>Para seguir este tutorial por primera vez, deberás instalar una serie de paquetes<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> que emplearemos: <code>quanteda</code>, <code>readtext</code>, <code>dplyr</code> y <code>stringr</code>. Esto se hace a través del comando: <code>install.packages()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="fu">c</span>(<span class="st">"quanteda"</span>, <span class="st">"readtext"</span>, <span class="st">"dplyr"</span>, <span class="st">"stringi"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="por-qué-lo-usamos" class="level4">
<h4 class="anchored" data-anchor-id="por-qué-lo-usamos">¿Por qué lo usamos?</h4>
<dl>
<dt><code>quanteda</code></dt>
<dd>
<p>Paquete de análisis de textos, incluyendo tokenización, conteo y limpieza de textos</p>
</dd>
<dt><code>readtext</code></dt>
<dd>
<p>Permite importar archivos de texto en varios formatos, facilitando la carga de datos</p>
</dd>
<dt><code>dplyr</code></dt>
<dd>
<p>Herramienta para manipulación y transformación de datos, útil para filtrar y organizar datos</p>
</dd>
<dt><code>stringi</code></dt>
<dd>
<p>Conjunto de funciones para trabajar con texto, especialmente útil para limpieza y manejo de expresiones regulares.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
</dd>
</dl>
<p><strong>¿Sabías qué…?</strong> ️🤓☝</p>
<div class="tip" style="background-color: #A8E6A1; border-left: 5px solid #A8E6A1; padding: 10px">
<p>La <strong>tokenización</strong> es el proceso de dividir un texto en unidades más pequeñas llamdas <em>tokens</em>. Estas unidades pueden ser palabras, símbolos, frases o incluso caracteres dependiendo del tipo de análisis que se vaya a realizar. En <code>quanteda</code> consideramos la palabra como la unidad mínima de trabajo. Imagínate que tienes la siguiente oración:</p>
<p>“Hola, ¿cómo estás?”</p>
<p>La tokenización de esta frase podría dar como resultado los siguientes tokens: “Hola”, “¿”, “cómo”, “estás”, “?”</p>
<p>Esto es especialmente útil cuando estamos trabajando con estudios relacionados con frecuencias de palabras.</p>
</div>
</section>
</section>
<section id="importación-de-datos-de-texto" class="level2">
<h2 class="anchored" data-anchor-id="importación-de-datos-de-texto">📄➡️🖥️Importación de datos de texto</h2>
<p>Vamos a vincular el archivo de&nbsp;texto en la aplicación de RStudios. Para ello vamos a cargar los paquetes que hemos instalado anteriormente&nbsp;con el comando <code>library("name")</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(quanteda)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readtext)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringi)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Es importante resaltar que, si no llamamos antes el paquete, los comandos que introduzcamos después no funcionarán o nos darán error. Asegúrate de cargar siempre la librería antes de empezar a trabajar.</p>
<p>Una vez cargados, el programa estará listo para leer nuestro archivo de texto. La formula que vamos a escribir para decirle a <code>quanteda</code> que archivo analizar será el siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>navalny_raw <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="fu">readtext</span>(<span class="st">"NAVALNY.txt"</span>))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(navalny_raw) <span class="ot">&lt;-</span> <span class="st">"navalny"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>❗ATENCIÓN:</strong> Si por alguna razón hiciesemos algún cambio en el contenido del archivo, deberemos de aplicar el paso anterior de nuevo. Cuando cargamos un archivo en R, se guarda una copia y cualquier cambio en el original no se refleja automáticamente.</p>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<p>Este comando carga el archivo <code>NAVALNY.txt</code> en el objeto <code>navalny_raw</code>, el cual contiene el contenido del texto. Vamos a desgranar este prompt para que pueda entenderse más facil:</p>
<ul>
<li><p><code>navalny_raw</code> es un objeto en R que almacena el texto como una cadena de caracteres (character vector). En <code>R</code> hablamos de <strong>objetos</strong> para referirnos a los contenedores donde almacenamos datos e información. En el caso anterior, el objeto <code>data_char_navalny</code> almacena el texto plano que vamos a utilizar. Existen distintos objetos con diferentes datos almacenados: matrices, números, listas jerarquizadas, así como un sin fin de combinaciones. A lo largo de este caso práctico trabajaremos con ellos para gestionar más facilmente el análisis cuantitativo.</p></li>
<li><p><code>&lt;-</code> emula a una flecha y básicamente indica la dirección de la acción. Al objeto <code>navalny_raw</code> estamos aplicándole una función</p></li>
<li><p><code>as.character()</code>: Se trata de la función que estamos aplicando. Esta función convierte todo lo que se contiene dentro de ella en carácter. En <code>R</code> toda función viene seguida por unos paréntesis dentro de los cuáles se incluyen los parámetros de dicha función. Si no hay contenido, se aplican los parámetros que la función trae por defecto.</p></li>
<li><p><code>readtext</code>: Aquí estamos empleando una función expecífica del paquete <code>readtext</code>. Si no hubiésemos cargado el paquete anteriormente, podríamos invocarlo específicamente para activar esta función con la notación <code>paquete::función</code>. Aquí, lo que le estamos diciendo a RStudio es que, del paquete <code>readtext</code>, aplique específicamente la función lectura que casualmente también se llama <code>readtext</code> . Dentro indicamos entrecomillada la ruta del archivo a importar. Un <strong>problema muy común</strong> que puede surgir a la hora de introducir la URL de la ubicación del archivo es expresarlo con barras laterales izquierdas ” \ “, tal y como viene en la barra de dirección del explorador de archivos de Windows, en vez de la derecha” / “. Si tienes problemas leer tu .txt ¡prueba con hacer este cambio!</p></li>
<li><p><code>names(navalny_raw) &lt;- "navalny"</code>: Asigna un nombre al objeto que contiene el texto, facilitando su identificación en futuros análisis.</p></li>
</ul>
<section id="comprobaciones" class="level4">
<h4 class="anchored" data-anchor-id="comprobaciones">🔍 Comprobaciones</h4>
<p>En el análisis cuantitativo toda precaución es poca. Vamos a verificar que el texto ha sido leído por el programa. Usaremos el paquete <code>stringi</code> para ver los primeros 75 caracteres de nuestro archivo y confirmar que los datos se cargaron bien.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Comprobar los primeros 75 caracteres del texto</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">stri_sub</span>(navalny_raw, <span class="dv">1</span>, <span class="dv">75</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2022\nJanuary 17th\nExactly one year ago today I came home, to Russia.\nI didn"</code></pre>
</div>
</div>
<p>Si hemos hecho los pasos bien, tendréis que haber recibir este texto de vuelta:</p>
<pre><code>[1] "2022\nJanuary 17th\nExactly one year ago today I came home, to Russia.\nI didn"</code></pre>
</section>
</section>
<section id="acotando-el-texto-a-analizar" class="level2">
<h2 class="anchored" data-anchor-id="acotando-el-texto-a-analizar">🗃️Acotando el texto a analizar</h2>
<p>Nuestro siguiente objetivo es seleccionar qué partes del texto vamos aplicar el análisis cuantitativo. Puede que nuestro foco de interés sea algun apartado concreto de nuestro material, por lo que vamos a crear un objeto que albergue un rango determinado dentro de nuestro fichero <code>txt</code> . Con esto, nos quitaremos toda la información innecesaria que puede ensuciar nuestros resultados.</p>
<p>El proceso que vamos a realizar a continuación es muy útil cuando los archivos que manejamos tienen ligados metadatos. Normalmente, esta metadata suele ser más un dolor de cabeza que otra cosa y es recomendable realizar una limpieza previa para que esos datos no se mezclen con el contenido de nuestro análisis. En este apartado seguiremos trabajando con el paquete <code>stringi</code>.</p>
<p>Si el texto contiene secciones que no necesitamos para el análisis, podemos filtrarlas o limpiarlas en esta etapa.</p>
<section id="paso-1-identificación-de-comienzo-y-fin-del-texto" class="level4">
<h4 class="anchored" data-anchor-id="paso-1-identificación-de-comienzo-y-fin-del-texto">PASO 1: Identificación de comienzo y fin del texto</h4>
<p>Para crear el objeto que albergue el rango de texto a analizar deberemos empezar indicando donde empieza y termina nuestra selección. Para ello, crearemos dos valores de posición: <code>start_v</code> y <code>end_v</code>, donde <code>start_</code> será: “2023, January 12th” y <code>end_v</code> “Alexei Navalny died”.</p>
<p>Localizado el rango que queremos, la forma de expresarlo en el programa sería el siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(start_v <span class="ot">&lt;-</span> <span class="fu">stri_locate_first_fixed</span>(navalny_raw, <span class="st">"2023</span><span class="sc">\n</span><span class="st">January 12th"</span>)[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 23654</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(end_v <span class="ot">&lt;-</span> <span class="fu">stri_locate_last_fixed</span>(navalny_raw, <span class="st">"Alexei Navalny died"</span>)[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 44099</code></pre>
</div>
</div>
<p>Si lo hemos aplicado bien, la función debería de devolver los siguientes resultados</p>
<ul>
<li><p>Para <code>start_value</code></p>
<pre><code>[1] 23653</code></pre></li>
</ul>
<!-- -->
<ul>
<li><p>Para <code>end_value</code></p>
<pre><code>[1] 44099</code></pre></li>
</ul>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li><p>Tanto <code>start_v</code> como <code>end_v</code> son nombres que hemos asignado a la posición específicas del texto. En sí, no significan nada. Solo decimos, a través de “&lt;-” que dichos nombres albergan una función de posicionamiento.</p></li>
<li><p>Las funciones del paquete <code>stringi</code>: <code>stri_locate_first_fixed</code> y <code>stri_locate_last_fixed</code> buscan y encuentran la primera coincidencia del valor entrecomillado que precede a nuestro objeto <code>data_char_NALVANY</code></p></li>
<li><p>El [1] es un indicador que le estamos dando a la función para que escoja la primera posición donde aparezca el texto que hayamos escogido.</p></li>
<li><p>Así, cuando vemos devuelto las respuestas <code>[1] 23653</code> y <code>[1] 44141</code> quiere decir que para <code>start_v</code> y <code>end_v</code> está asignado el primer valor donde aparece dichas expresiones , localizadas por primera vez en la posición 23653 y 44141 de nuestro texto.</p></li>
</ul>
</section>
<section id="paso-2-nuevo-objeto" class="level4">
<h4 class="anchored" data-anchor-id="paso-2-nuevo-objeto">PASO 2: Nuevo objeto</h4>
<p>Creado nuestro punto de inicio y final de nuestra zona de trabajo, haremos un objeto que alberge dicho rango. Lo llamaremos: <code>navalny_fix</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>navalny_fix <span class="ot">&lt;-</span> <span class="fu">stri_sub</span>(navalny_raw, start_v, end_v)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(navalny_fix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>Al iniciar el código el valor que os ha tenido que recuperar, además de almacenar el objeto en la pestaña <code>Environment</code> de RStuido, es:</p>
<pre><code>[1] 1</code></pre>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li><p><code>navalny_fix</code> es el nombre del objeto que almacena la función que ha sido asignada. En este caso, a través de <code>stri_sub</code>, estamos extrayendo una parte del texto <code>navalny_fix</code> . A diferencia del caso anterior, aquí le estamos pidiendo que, en vez de que recuper un número detemrinado de caracteres, escoja todos los que hay comprendidos entre las posiciones que hemos dado a <code>start_v</code> y a <code>end_v</code>. Con esto nos aseguramos que el objeto <code>navalny_fix</code> siempre trabaje en los rangos que nos interesa analizar.</p></li>
<li><p><code>length(navalny_fix)</code> es una expresión que usamos para comprobar cuandos valores existen en nuestro objeto. Es una forma de asegurarnos de que nuestro objeto solo tiene un vector y no es un conjunto de fragmentos de texto. Por eso, al introducirlo, el programa nos devuelve el valor 1 porque solo hay 1 valor dentro de nuestro objeto.</p></li>
</ul>
</section>
</section>
<section id="limpiando-datos" class="level2">
<h2 class="anchored" data-anchor-id="limpiando-datos">🗑️ Limpiando datos</h2>
<p>Ya tenemos nuestro set de datos, nos toca empezar a limpiar antes de tokenizar y empezar a analizar.</p>
<section id="paso-1-comprobar-la-estructura-del-texto" class="level4">
<h4 class="anchored" data-anchor-id="paso-1-comprobar-la-estructura-del-texto">PASO 1: Comprobar la estructura del texto</h4>
<p>Vamos a abrir un momento nuestro archivo para ver lo que contiene. Aquí te enseño las primeras líneas:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>2023
January 12th
In my two years behind bars, my only truly original story is the one about the
psycho. Everything else has been told and described numerous times. If you
open any book by a Soviet dissident, there will be endless stories of punishment
cells, hunger strikes, violence, provocations, lack of medical care. Nothing new.
But my story about the psycho is fresh; at least,I’ve never seen or heard
anything like it

So, let me give you an idea about the shizo, the place where I sit all the time. It
is a narrow corridor with cells on either side. The metal doors offer little to no
soundproofing, plus there are ventilation holes above the doors, so two people
sitting in opposite cells can have a conversation without even raising their
voices. This is the main reason there has never been anyone in the cell opposite
mine, or in my entire eight-cell section. I am the only one there, and I have</code></pre>
</div>
</div>
<p>Aquí queda más clara la estructura del texto:</p>
<ul>
<li><p>Cada entrada del diario empieza con el año en la primera línea</p></li>
<li><p>Dentro de cada año, se dividen por días las entradas</p></li>
<li><p>Los párrafos están separados por saltos de línea</p></li>
<li><p>Las entradas están separadas entre sí también por una linea en blanco.</p></li>
</ul>
<p>A continuación lo que vamos a hacer es crear un objeto lista<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, en la que cada elemento será una entrada del diario.</p>
</section>
<section id="paso-2-conversión-del-texto-en-vectores" class="level4">
<h4 class="anchored" data-anchor-id="paso-2-conversión-del-texto-en-vectores">PASO 2: Conversión del texto en vectores</h4>
<p>Ahora que comprendemos la estructura, vamos a separar el texto en entradas diarias, preservando la estructura de párrafos dentro de cada entrada. Primero dividimos el texto en líneas, donde cada línea se convierte en un elemento de un vector. Esto nos permite identificar las lineas que contienen fechas y separar las entradas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convertir el texto en un vector de líneas</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>lines <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">strsplit</span>(navalny_fix, <span class="st">'</span><span class="sc">\n</span><span class="st">'</span>)) <span class="co"># \n indica un salto de línea</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li><p><code>strsplit()</code> divide el texto por saltos de línea (<code>"\n"</code>), creando un vector en el que cada línea es un elemento independiente.</p></li>
<li><p>Usamos <code>unlist()</code> para simplificar la estructura y trabajar con un vector plano.</p></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(lines) <span class="co"># Veamos las primeras seis líneas de nuestro objeto</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2023"                                                                             
[2] "January 12th"                                                                     
[3] "In my two years behind bars, my only truly original story is the one about the"   
[4] "psycho. Everything else has been told and described numerous times. If you"       
[5] "open any book by a Soviet dissident, there will be endless stories of punishment" 
[6] "cells, hunger strikes, violence, provocations, lack of medical care. Nothing new."</code></pre>
</div>
</div>
</section>
<section id="paso-3-creación-de-índices-para-identificar-entradas" class="level4">
<h4 class="anchored" data-anchor-id="paso-3-creación-de-índices-para-identificar-entradas">PASO 3: Creación de índices para identificar entradas</h4>
<p>En este paso, vamos a crear los <strong>índices</strong> que nos permitirán identificar las líneas en el texto que corresponden a cada año y a cada día. Esto nos ayudará a estructurar las entradas en el próximo paso.</p>
<ol type="1">
<li>Utilizando expresiones regulares, vamos a identificar las líneas que contengan sólo el año. Estas líneas marcan el inicio de cada conjunto de entradas anuales</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>year_indices <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">"^</span><span class="sc">\\</span><span class="st">d{4}$"</span>, lines)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(year_indices) <span class="co"># Muestra las líneas que contienen el año</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]   1 295</code></pre>
</div>
</div>
<ol start="2" type="1">
<li>Hemos identificado dos líneas que incluyen el año. Ahora haremos lo mismo para las líneas que encuentren el mes y el día</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>day_indices <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">"^(January|February|March|April|May|June|July|August|September|October|November|December)</span><span class="sc">\\</span><span class="st">s+</span><span class="sc">\\</span><span class="st">d{1,2}(st|nd|rd|th)?$"</span>, lines)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(day_indices) <span class="co"># Número de entradas identificadas</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 11</code></pre>
</div>
</div>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li><p><code>year_indices</code> contiene los índices de las líneas con los años, es decir, las posiciones donde comienza cada año en el texto. La expresión regular <code>^\\d{4}</code> busca cuatro dígitos al inicio de la línea.</p></li>
<li><p><code>month_day_indices</code> contiene los índices de las líneas con fechas diarias, indicando el inicio de cada día dentro de los años.</p>
<ul>
<li><p><code>(January|February|...)</code>: Busca un mes escrito en inglés.</p></li>
<li><p><code>\\s+</code>: Representa uno o más espacios.</p></li>
<li><p><code>\\d{1,2}(st|nd|rd|th)?$</code>: Busca el día, que tendrá uno o dos dígitos y que puede ir seguido de “st”, “nd”, “rd”, o “th” al final de la línea.</p></li>
</ul></li>
</ul>
</section>
<section id="paso-4-creación-de-entradas-del-diario" class="level4">
<h4 class="anchored" data-anchor-id="paso-4-creación-de-entradas-del-diario">PASO 4: Creación de entradas del diario</h4>
<p>Ahora que tenemos los índices para los años y días, podemos organizar el texto en <strong>entradas anidadas</strong>: cada año será un grupo principal, y dentro de cada año, cada día será una entrada individual.</p>
<p>El siguiente código es un poco tocho, te intento explicar:</p>
<ol type="1">
<li>Creamos las entradas por año. Para esto utilizamos el objeto <code>year_indices</code> que construimos antes.</li>
<li>Creamos sublistas dentro de cada año con nuestro objeto <code>month_day_indices</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Dividimos el texto en entradas anidadas (por año y día)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">seq_along</span>(year_indices), </span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">function</span>(i) {</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    start_year <span class="ot">&lt;-</span> year_indices[i]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    end_year <span class="ot">&lt;-</span> <span class="cf">if</span> (i <span class="sc">&lt;</span> <span class="fu">length</span>(year_indices))</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      year_indices[i <span class="sc">+</span> <span class="dv">1</span>] <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">length</span>(lines)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extraemos las líneas correspondientes al año actual</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    year_lines <span class="ot">&lt;-</span> lines[start_year<span class="sc">:</span>end_year]</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Encontrar las entradas diarias dentro del año actual</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    day_indices <span class="ot">&lt;-</span> <span class="fu">grep</span>(</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>      <span class="st">"^(January|February|March|April|May|June|July|August|September|October|November|December)</span><span class="sc">\\</span><span class="st">s+</span><span class="sc">\\</span><span class="st">d{1,2}(st|nd|rd|th)?$"</span>,</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>      year_lines</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Crear una sublista para cada día dentro del año</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="fu">seq_along</span>(day_indices), <span class="cf">function</span>(j) {</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>      start_day <span class="ot">&lt;-</span> day_indices[j]</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>      end_day <span class="ot">&lt;-</span> <span class="cf">if</span> (j <span class="sc">&lt;</span> <span class="fu">length</span>(day_indices))</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>        day_indices[j <span class="sc">+</span> <span class="dv">1</span>] <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">length</span>(year_lines)</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>      year_lines[start_day<span class="sc">:</span>end_day]</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>      })</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Devolver una lista con el año y sus entradas diarias</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list</span>(<span class="at">year =</span> year_lines[<span class="dv">1</span>], <span class="at">entries =</span> entries)</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li><p>Cada elemento en <code>yearly_entries</code> es un año completo</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(yearly_entries[[<span class="dv">1</span>]]<span class="sc">$</span>year) <span class="co"># primer año</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2023"</code></pre>
</div>
</div></li>
<li><p>Dentro de cada año, <code>entries</code> contiene las entradas diarias como sublistas, donde cada día es un vector de párrafos</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(yearly_entries[[<span class="dv">1</span>]]<span class="sc">$</span>entries)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 9</code></pre>
</div>
</div></li>
</ul>
<p>Para ello, hemos combinado diferentes funciones en un sólo script:</p>
<ul>
<li><p><code>lapply()</code> sirve para aplicar una función a cada elemento de un vector o lista. En nuestro caso, itera sobre cada índice de <code>year_indices</code>, procesando el texto correspondiente a cada ño. Genera una lista <code>yearly_indices</code>donde cada elemento representa un año y sus entradas diarias. La segunda vez que la empleo es para crear sublistas para cada día dentro del año, aplicándola sobre <code>day_indices</code>.</p></li>
<li><p><code>seq_along()</code> genera una secuencia de números que corresponden a la longitud de un vector o lista. Lo utilizo para generar una secuencia de índices a iterar sobre los años y sobre los días dentro de cada año.</p></li>
<li><p><code>grep()</code> busca patrones específicos dentro de un vector, tal y como hicimos antes.</p></li>
<li><p><code>if</code>dentro de <code>lapply()</code>define los límites de inicio y fin de cada año.</p></li>
<li><p><code>list()</code> crea la lista que almacena todas las entradas.</p></li>
</ul>
</section>
</section>
<section id="a-la-tokenización" class="level2">
<h2 class="anchored" data-anchor-id="a-la-tokenización">🗿 ¡A la tokenización!</h2>
<p>Ya tenemos nuestro texto bien organizado y estructurado. Toca dividir aún más y limpiar. Para ello vamos a hacer lo siguiente:</p>
<ol type="1">
<li>Convertimos el texto en minúsculas y eliminaos los signos de puntuación</li>
<li>Tokenizamos el texto dividiéndolo en palabras. De manera que nuestra unidad de análisis será la palabra<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</li>
<li>Eliminamos todas las palabras vacías<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> para quedarnos sólo con aquellas relevantes para nuestro análisis.</li>
</ol>
<section id="paso-1-texto-en-minúscula-y-puntuación-fuera" class="level4">
<h4 class="anchored" data-anchor-id="paso-1-texto-en-minúscula-y-puntuación-fuera">PASO 1: Texto en minúscula y puntuación fuera</h4>
<p>Para asegurarnos que palabras idénticas no se traten como diferentes por su formato, converitmos todo el texto a minúsculas y eliminamos puntuación.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convertir cada entrada diaria a minúsculas y eliminar signos de puntuación</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(yearly_entries, <span class="cf">function</span>(year) {</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  year<span class="sc">$</span>entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(year<span class="sc">$</span>entries, <span class="cf">function</span>(entry) {</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convertir el texto a minúsculas y eliminar puntuación</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    entry <span class="ot">&lt;-</span> <span class="fu">char_tolower</span>(entry)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    entry <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="st">"[[:punct:]]"</span>, <span class="st">""</span>, entry)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    entry</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  year  <span class="co"># Devolver la lista de año modificada</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li><p>La función <code>char_tolower()</code> convierte el texto en minúsculas.</p></li>
<li><p>La función <code>gsub()</code> sustituye un patrón de texto por otro. En nuestro caso, le hemos pedido que busque cualquier signo de puntuación empleando la expresión regular <code>[[:punct:]]</code> y la reemplace por nada.</p></li>
<li><p>Después hemos pedido que incluya estos cambios nuevamente en nuestro objeto <code>yearly_entries</code>.</p></li>
</ul>
<p>Si observas las primeras líneas de una entrada, verás que todo ha funcionado tal y como esperábamos:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "january 12th"                                                                   
[2] "in my two years behind bars my only truly original story is the one about the"  
[3] "psycho everything else has been told and described numerous times if you"       
[4] "open any book by a soviet dissident there will be endless stories of punishment"
[5] "cells hunger strikes violence provocations lack of medical care nothing new"    </code></pre>
</div>
</div>
</section>
<section id="paso-2-tokenización" class="level4">
<h4 class="anchored" data-anchor-id="paso-2-tokenización">PASO 2: Tokenización</h4>
<p>Para que el programa pueda analizar y realizar manipulaciones sobre las palabras de forma individualizada, vamos a convertir a cada una de ellas en pequeños valores que llamamos <strong>tokens.</strong></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tokenizar cada entrada diaria dentro de cada año</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(yearly_entries, <span class="cf">function</span>(year) {</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  year<span class="sc">$</span>entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(year<span class="sc">$</span>entries, <span class="cf">function</span>(entry) {</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">tokens</span>(entry, <span class="at">what =</span> <span class="st">"word"</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  year  <span class="co"># Devolver la lista de año modificada</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li><p>Siguiendo la misma estructura de la vez anterior, hemos incorporado la función <code>tokens()</code> y lo hemos aplicado al objeto <code>entry</code></p></li>
<li><p>Además, hemos utilizado el parámetro <code>what=</code> en el que indicamos el nivel. En nuestro caso tokenizamos por palabras. Otras opciones son por caracteres (<code>character</code>) y frases (<code>sentence</code>).</p></li>
</ul>
<p>Ahora en lugar de contener un listado de filas por entrada, lo que tengo es una bolsa de palabras:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Tokens consisting of 3 documents.
text1 :
[1] "january" "12th"   

text2 :
 [1] "in"       "my"       "two"      "years"    "behind"   "bars"    
 [7] "my"       "only"     "truly"    "original" "story"    "is"      
[ ... and 4 more ]

text3 :
 [1] "psycho"     "everything" "else"       "has"        "been"      
 [6] "told"       "and"        "described"  "numerous"   "times"     
[11] "if"         "you"       </code></pre>
</div>
</div>
</section>
<section id="paso-3-eliminación-de-palabras-vacías" class="level4">
<h4 class="anchored" data-anchor-id="paso-3-eliminación-de-palabras-vacías">PASO 3: Eliminación de palabras vacías</h4>
<p>Para centrarnos en las palabras significativas, eliminamos las <strong>palabras vacías</strong> (stopwords), que suelen ser términos comunes y poco informativos, como “el”, “de”, “y”. Esto permite que el análisis se centre en términos con más contenido semántico.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Eliminar palabras vacías en inglés en cada entrada diaria</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>yearly_entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(yearly_entries, <span class="cf">function</span>(year) {</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  year<span class="sc">$</span>entries <span class="ot">&lt;-</span> <span class="fu">lapply</span>(year<span class="sc">$</span>entries, <span class="cf">function</span>(entry) {</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">tokens_remove</span>(entry, <span class="at">pattern =</span> <span class="fu">stopwords</span>(<span class="st">"en"</span>)) </span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  year  <span class="co"># Devolver la lista de año modificada</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>🤔¿Qué hemos hecho?</strong></p>
<ul>
<li>Aquí empleamos la función <code>tokens_remove()</code> otra vez aplicada al objeto <code>entry</code>, en este caso empleamos el parámetro <code>pattern =</code> para indicar que eliminaremos los tokens que representen palabras vacías, en paréntesis incluimos la lengua a través de su código ISO, en nuestro caso el inglés. <a href="https://www.rdocumentation.org/packages/stopwords/versions/2.3">Aquí tienes el listado completo de idiomas</a>. El paquete <code>stopwords</code> permite asimismo crear y/o añadir tus propias palabras vacías.</li>
</ul>
<p>Fíjate cómo, en comparación con el fragmento anterior, se han eliminado palabras como “in”, “my” u “only”.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Tokens consisting of 3 documents.
text1 :
[1] "january" "12th"   

text2 :
[1] "two"      "years"    "behind"   "bars"     "truly"    "original" "story"   
[8] "one"     

text3 :
[1] "psycho"     "everything" "else"       "told"       "described" 
[6] "numerous"   "times"     </code></pre>
</div>
</div>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Como habrás notado, es posible juntar todos estos pasos en uno sólo. Aquí lo mostramos por trozos para que vayas comprendiendo el proceso, pero podríamos hacer todo esto de una vez.</p>
</div>
</div>
</div>
<p><strong>¿Sabías qué…?</strong> ️🤓☝</p>
<div class="tip" style="background-color: #A8E6A1; border-left: 5px solid #A8E6A1; padding: 10px">
<p>En inglés, es posible que el texto venga acompañado de apóstrofes como en los casos de <code>don't</code> y <code>he's</code>. Aquí, <code>quanteda</code> no tomará las <code>'t</code> ni las <code>'s</code> como elementos aislados, sino que lo mantendrá unida a la palabra para respetar el significado original.</p>
</div>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><code>R</code> es un lenguaje de programación abierto y colaborativo que sigue una estructura totalmente descentralizada. Cuando instalamos <code>R</code> por primera vez, sólo instalamos sus funcionalidades básicas. Todas aquellas funcionalidades adicionales llevadas a cabo por terceras personas deben instalarse en lo que se denominan <strong>paquetes</strong> o <strong>libraries</strong> en inglés.</p>
<p>Cada vez que vayas a emplear un paquete, debes cargarlo, por defecto, cada vez que abres <code>R</code> estos paquetes no están cargados.</p>
</div>
</div>
</div>
<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn2"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Una <strong>expresión regular</strong> es un patrón de búsqueda utilizado para manipular texto específico en una cadena. Facilita tareas como eliminar caracteres no deseados o extraer información específica (e.g., fechas o números). Es especialmente útil en la limpieza y preprocesamiento de datos textuales.</p>
</div>
</div>
</div>
<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn3"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Una <strong>lista</strong> es una estructura de datos qeu puede contener elementos de diferentes tipos (numérico, caractéres, vectores o incluso otras listas) en un solo objecto. Cada elemento en una lista se puede acceder de forma individual usando índices. Esto se hace utilizando corchetes dobles. Por ejemplo si queremos ver el segundo elemento de la lista <code>lista</code>, lo indicaremos así: <code>lista[[2]]</code>.</p>
</div>
</div>
</div>
<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn4"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Aquí es importante diferenciar entre análisis textual y un análisis semántico. En el análisis de textos examinamos cuestiones como la frecuencia de las palabras, patrones o estructura, sin considerar el significado de cada palabra. Se trataría de un paso previo al análisis semántico donde nos centramos en el significado y el contexto de las palabras.</p>
</div>
</div>
</div>
<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn5"><div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Las <strong>palabras vacías</strong> son términos comunes (como “el”, “de”, “y”) que suelen aparecer con mucha frecuencia en el texto, pero aportan poco significado o valor informativo al análisis. Estas palabras se eliminan generalmente para centrar el análisis en los términos más relevantes.</p>
</div>
</div>
</div>
<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>